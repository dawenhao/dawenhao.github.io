(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{508:function(t,a,e){"use strict";e.r(a);var s=e(4),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("The term computer graphics describes any use of computers to create and manipulate images. This book introduces the algorithmic and mathematical tools that can be used to create all kinds of images—realistic visual effects, informative technical illustrations, or beautiful computer animations. Graphics can be two- or three-dimensional; images can be completely synthetic or can be produced by manipulating photographs. This book is about the fundamental algorithms and mathematics, especially those used to produce synthetic images of three-dimensional objects and scenes."),e("br"),t._v("\n术语“计算机图形”描述了使用计算机创建和操纵图像的任何方式。 本书介绍了可用于创建各种图像的算法和数学工具-逼真的视觉效果，内容丰富的技术插图或精美的计算机动画。 图形可以是二维的，也可以是三维的。 图像可以是完全合成的，也可以通过处理照片来生成。 本书介绍了基本的算法和数学，尤其是用于生成三维物体和场景的合成图像的算法。")]),t._v(" "),e("p",[t._v("  Actually doing computer graphics inevitably requires knowing about specific hardware, file formats, and usually a graphics API (see Section 1.3) or two. Computer graphics is a rapidly evolving field, so the specifics of that knowledge are a moving target. Therefore, in this book we do our best to avoid depending on any specific hardware or API. Readers are encouraged to supplement the text with relevant documentation for their software and hardware environment. Fortunately, the culture of computer graphics has enough standard terminology and concepts that the discussion in this book should map nicely to most environments."),e("br"),t._v("\n  实际上，进行计算机图形处理不可避免地需要了解特定的硬件，文件格式，通常还需要了解一两个图形API（请参阅第1.3节）。 计算机图形学是一个快速发展的领域，因此该知识的具体内容是一个不断变化的目标。 因此，在本书中，我们尽力避免依赖任何特定的硬件或API。 鼓励读者使用有关其软件和硬件环境的相关文档来补充文本。 幸运的是，计算机图形文化具有足够的标准术语和概念，因此本书中的讨论应很好地映射到大多数环境。")]),t._v(" "),e("p",[t._v("  This chapter defines some basic terminology and provides some historical background, as well as information sources related to computer graphics."),e("br"),t._v("\n  本章定义了一些基本术语，并提供了一些历史背景以及与计算机图形学有关的信息源。")]),t._v(" "),e("h2",{attrs:{id:"_1-1-图形领域-graphics-areas"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-图形领域-graphics-areas"}},[t._v("#")]),t._v(" 1.1 图形领域(Graphics Areas)")]),t._v(" "),e("p",[t._v("Imposing categories on any field is dangerous, but most graphics practitioners would agree on the following major areas of computer graphics:"),e("br"),t._v("\n在任何领域上强加分类都是危险的，但是大多数图形从业者会在计算机图形学的以下主要领域达成共识：")]),t._v(" "),e("ul",[e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Modeling")]),t._v(" deals with the mathematical specification of shape and appearance properties in a way that can be stored on the computer. For example, a coffee mug might be described as a set of ordered 3D points along with some interpolation rule to connect the points and a reflection model that describes how light interacts with the mug.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("建模")]),t._v("以可以存储在计算机上的方式处理形状和外观属性的数学规范。 例如，咖啡杯可能被描述为一组有序的3D点以及一些连接点的插值规则和描述光如何与杯子交互的反射模型。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Rendering")]),t._v(" is a term inherited from art and deals with the creation of shaded images from 3D computer models.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("渲染")]),t._v("是一个继承自艺术的术语，涉及从3D计算机模型创建阴影图像。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Animation")]),t._v(" is a technique to create an illusion of motion through sequences of images. Animation uses modeling and rendering but adds the key issue of movement over time, which is not usually dealt with in basic modeling and rendering.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("动画")]),t._v("是一种通过图像序列产生运动幻觉的技术。 动画使用建模和渲染，但是增加了随时间推移运动的关键问题，而基本建模和渲染通常不会解决这一问题。")],1)])]),t._v(" "),e("p",[t._v("There are many other areas that involve computer graphics, and whether they are core graphics areas is a matter of opinion. These will all be at least touched on in the text. Such related areas include the following:"),e("br"),t._v("\n还有许多其他涉及计算机图形学的领域，它们是否是核心图形学领域还是一个意见问题。 这些都将至少在文本中涉及。 这些相关领域包括：")]),t._v(" "),e("ul",[e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("User interaction")]),t._v(" deals with the interface between input devices such as mice and tablets, the application, feedback to the user in imagery, and other sensory feedback. Historically, this area is associated with graphics largely because graphics researchers had some of the earliest access to the input/output devices that are now ubiquitous.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("用户交互")]),t._v("处理诸如鼠标和平板电脑之类的输入设备之间的界面，应用程序，图像中对用户的反馈以及其他感官反馈。 从历史上看，该领域与图形相关，主要是因为图形研究人员最早可以访问现在无处不在的输入/输出设备。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Virtual reality")]),t._v(" attempts to immerse the user into a 3D virtual world. This typically requires at least stereo graphics and response to head motion. For true virtual reality, sound and force feedback should be provided as well. Because this area requires advanced 3D graphics and advanced display technology, it is often closely associated with graphics.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("虚拟现实")]),t._v("试图使用户沉浸在3D虚拟世界中。 这通常至少需要立体图形和对头部运动的响应。 对于真实的虚拟现实，还应该提供声音和力量反馈。 因为此区域需要高级3D图形和高级显示技术，所以它通常与图形密切相关。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Visualization")]),t._v(" attempts to give users insight into complex information via visual display. Often there are graphic issues to be addressed in a visualization problem.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("可视化")]),t._v("试图通过可视化显示使用户深入了解复杂的信息。 通常在可视化问题中要解决图形问题。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Image processing")]),t._v(" deals with the manipulation of 2D images and is used in both the fields of graphics and vision.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("图像处理")]),t._v("处理2D图像，并且在图形和视觉领域中都使用。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("3D scanning")]),t._v(" uses range-finding technology to create measured 3D models. Such models are useful for creating rich visual imagery, and the processing of such models often requires graphics algorithms.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("3D扫描")]),t._v("使用测距技术创建测量的3D模型。 此类模型可用于创建丰富的视觉图像，并且此类模型的处理通常需要图形算法。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Computational photography")]),t._v(" is the use of computer graphics, computer vision, and image processing methods to enable new ways of photographically capturing objects, scenes, and environments.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("计算摄影")]),t._v("是使用计算机图形，计算机视觉和图像处理方法来实现以摄影方式捕获对象，场景和环境的新方法。")],1)])]),t._v(" "),e("h2",{attrs:{id:"_1-2-主要应用-major-application"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-主要应用-major-application"}},[t._v("#")]),t._v(" 1.2 主要应用(Major Application)")]),t._v(" "),e("p",[t._v("Almost any endeavor can make some use of computer graphics, but the major consumers of computer graphics technology include the following industries:"),e("br"),t._v("\n几乎所有的努力都可以利用计算机图形学，但是计算机图形学技术的主要消费者包括以下行业：")]),t._v(" "),e("ul",[e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Video games")]),t._v(" increasingly use sophisticated 3D models and rendering algorithms.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("电子游戏")]),t._v("越来越多地使用复杂的3D模型和渲染算法。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Cartoons")]),t._v(" are often rendered directly from 3D models. Many traditional 2D cartoons use backgrounds rendered from 3D models, which allow a continuously moving viewpoint without huge amounts of artist time.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("卡通")]),t._v("通常直接从3D模型中渲染。 许多传统的2D卡通都使用从3D模型渲染的背景，从而无需花费大量艺术家时间就可以连续不断地移动视点。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Visual effects")]),t._v(" use almost all types of computer graphics technology. Almost every modern film uses digital compositing to superimpose backgrounds with separately filmed foregrounds. Many films also use 3D modeling and animation to create synthetic environments, objects, and even characters that most viewers will never suspect are not real.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("视觉效果")]),t._v("几乎使用所有类型的计算机图形技术。 几乎每部现代电影都使用数字合成技术将背景与单独拍摄的前景叠加在一起。 许多电影还使用3D建模和动画来创建合成环境，对象，甚至是大多数观众永远不会怀疑不是真实的角色。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Animated films")]),t._v(" use many of the same techniques that are used for visual effects, but without necessarily aiming for images that look real.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("动画电影")]),t._v("使用了许多与视觉效果相同的技术，但不一定要针对看起来真实的图像。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("CAD/CAM")]),t._v(" stands for computer-aided design and computer-aided manufacturing. These fields use computer technology to design parts and products on the computer and then, using these virtual designs, to guide the manufacturing process. For example, many mechanical parts are designed in a 3D computer modeling package and then automatically produced on a computer-controlled milling device.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("CAD/CAM")]),t._v("代表计算机辅助设计和计算机辅助制造。 这些领域使用计算机技术来设计计算机上的零件和产品，然后使用这些虚拟设计来指导制造过程。 例如，许多机械零件是在3D计算机建模包中设计的，然后在计算机控制的铣削设备上自动生产。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Simulation")]),t._v(" can be thought of as accurate video gaming. For example, a flight simulator uses sophisticated 3D graphics to simulate the experience of flying an airplane. Such simulations can be extremely useful for initial training in safety-critical domains such as driving, and for scenario training for experienced users such as specific fire-fighting situations that are too costly or dangerous to create physically.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("模拟")]),t._v("可以视为准确的视频游戏。 例如，飞行模拟器使用复杂的3D图形来模拟飞行飞机的体验。 这样的模拟对于安全关键领域（如驾驶）的初始培训以及对经验丰富的用户的场景培训（如过于昂贵或难以实际创建的特定消防情况）非常有用。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Medical imaging")]),t._v(" creates meaningful images of scanned patient data. For example, a computed tomography (CT) dataset is composed of a large 3D rectangular array of density values. Computer graphics is used to create shaded images that help doctors extract the most salient information from such data.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("医学成像")]),t._v("创建扫描的患者数据的有意义的图像。 例如，计算机断层扫描（CT）数据集由密度值的大型3D矩形阵列组成。 计算机图形学用于创建阴影图像，以帮助医生从此类数据中提取最显着的信息。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Information visualization")]),t._v(" creates images of data that do not necessarily have a “natural” visual depiction. For example, the temporal trend of the price of ten different stocks does not have an obvious visual depiction, but clever graphing techniques can help humans see the patterns in such data.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("信息可视化")]),t._v("可创建不一定具有“自然”视觉描述的数据图像。 例如，十种不同股票的价格的时间趋势没有明显的视觉描绘，但是聪明的绘图技术可以帮助人们查看此类数据中的模式。")],1)])]),t._v(" "),e("h2",{attrs:{id:"_1-3-图形api-graphics-apis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-图形api-graphics-apis"}},[t._v("#")]),t._v(" 1.3 图形API(Graphics APIs)")]),t._v(" "),e("p",[t._v("A key part of using graphics libraries is dealing with a graphics API. An application program interface (API) is a standard collection of functions to perform a set of related operations, and a graphics API is a set of functions that perform basic operations such as drawing images and 3D surfaces into windows on the screen."),e("br"),t._v("\n使用图形库的关键部分是处理图形API。 应用程序接口（API）是执行一组相关操作的标准功能集合，而图形API是执行诸如将图像和3D表面绘制到屏幕上的窗口之类的基本操作的一组功能。")]),t._v(" "),e("p",[t._v("  Every graphics program needs to be able to use two related APIs: a graphics API for visual output and a user-interface API to get input from the user. There are currently two dominant paradigms for graphics and user-interface APIs. The first is the integrated approach, exemplified by Java, where the graphics and userinterface toolkits are integrated and portable packages that are fully standardized and supported as part of the language. The second is represented by Direct3D and OpenGL, where the drawing commands are part of a software library tied to a language such as C++, and the user-interface software is an independent entity that might vary from system to system. In this latter approach, it is problematic to write portable code, although for simple programs it may be possible to use a portable library layer to encapsulate the system specific user-interface code."),e("br"),t._v("\n  每个图形程序都必须能够使用两个相关的API：用于视觉输出的图形API和用于从用户获取输入的用户界面API。 当前，图形和用户界面API有两种主要的范例。 第一种是集成方法，以Java为例，其中图形和用户界面工具包是集成的和可移植的程序包，这些程序包已完全标准化并作为语言的一部分得到支持。 第二个由Direct3D和OpenGL表示，其中绘图命令是与诸如C ++之类的语言绑定的软件库的一部分，并且用户界面软件是一个独立的实体，可能因系统而异。 在后一种方法中，编写可移植代码是有问题的，尽管对于简单程序而言，可能可以使用可移植库层来封装系统特定的用户界面代码。")]),t._v(" "),e("p",[t._v("  Whatever your choice of API, the basic graphics calls will be largely the same, and the concepts of this book will apply."),e("br"),t._v("\n  无论选择哪种API，基本的图形调用都将基本相同，并且本书的概念也将适用。")]),t._v(" "),e("h2",{attrs:{id:"_1-4-图形管线-graphics-pipeline"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-图形管线-graphics-pipeline"}},[t._v("#")]),t._v(" 1.4 图形管线(Graphics Pipeline)")]),t._v(" "),e("p",[t._v("Every desktop computer today has a powerful 3D graphics pipeline. This is a special software/hardware subsystem that efficiently draws 3D primitives in perspective. Usually these systems are optimized for processing 3D triangles with shared vertices. The basic operations in the pipeline map the 3D vertex locations to 2D screen positions and shade the triangles so that they both look realistic and appear in proper back-to-front order."),e("br"),t._v("\n如今，每台台式计算机都具有强大的3D图形管线。这是一个特殊的软件/硬件子系统，可以有效地绘制3D图元的透视图。通常，这些系统经过优化以处理具有共享顶点的3D三角形。流水线中的基本操作将3D顶点位置映射到2D屏幕位置，并对三角形进行阴影处理，以使它们看起来逼真并以适当的前后顺序显示。")]),t._v(" "),e("p",[t._v("  Although drawing the triangles in valid back-to-front order was once the most important research issue in computer graphics, it is now almost always solved using the z-buffer, which uses a special memory buffer to solve the problem in a brute-force manner."),e("br"),t._v("\n  尽管以有效的从后到前的顺序绘制三角形曾经是计算机图形学中最重要的研究问题，但现在几乎总是使用z缓冲区解决了该问题，z缓冲区使用特殊的内存缓冲区以蛮力的方式解决了该问题。")]),t._v(" "),e("p",[t._v("  It turns out that the geometric manipulation used in the graphics pipeline can be accomplished almost entirely in a 4D coordinate space composed of three traditional geometric coordinates and a fourth homogeneous coordinate that helps with perspective viewing. These 4D coordinates are manipulated using 4 × 4 matrices and 4-vectors. The graphics pipeline, therefore, contains much machinery for efficiently processing and composing such matrices and vectors. This 4D coordinate system is one of the most subtle and beautiful constructs used in computer science, and it is certainly the biggest intellectual hurdle to jump when learning computer graphics. A big chunk of the first part of every graphics book deals with these coordinates."),e("br"),t._v("\n  事实证明，图形流水线中使用的几何操作几乎可以完全在4D坐标空间中完成，该空间由三个传统的几何坐标和一个有助于透视图查看的第四个齐次坐标组成。这些4D坐标是使用4×4矩阵和4个向量处理的。因此，图形流水线包含许多机制，可以有效地处理和合成这样的矩阵和向量。这种4D坐标系是计算机科学中使用的最微妙，最精美的结构之一，并且无疑是学习计算机图形学时跳跃的最大智力障碍。每本图形书的第一部分的很大一部分都处理这些坐标。")]),t._v(" "),e("p",[t._v("  The speed at which images can be generated depends strongly on the number of triangles being drawn. Because interactivity is more important in many applications than visual quality, it is worthwhile to minimize the number of triangles used to represent a model. In addition, if the model is viewed in the distance, fewer triangles are needed than when the model is viewed from a closer distance. This suggests that it is useful to represent a model with a varying level of detail (LOD)."),e("br"),t._v("\n  生成图像的速度在很大程度上取决于所绘制的三角形的数量。由于交互性在许多应用程序中比视觉质量更重要，因此有必要将用于表示模型的三角形的数量最小化。另外，如果在远处观看模型，则与从近处观看模型时相比，需要的三角形更少。这表明表示具有多细节层次（LOD）的模型很有用。")]),t._v(" "),e("h2",{attrs:{id:"_1-5-数值问题-numerical-issues"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-数值问题-numerical-issues"}},[t._v("#")]),t._v(" 1.5 数值问题(Numerical Issues)")]),t._v(" "),e("p",[t._v("Many graphics programs are really just 3D numerical codes. Numerical issues are often crucial in such programs. In the “old days,” it was very difficult to handle such issues in a robust and portable manner because machines had different internal representations for numbers, and even worse, handled exceptions in different and incompatible ways. Fortunately, almost all modern computers conform to the IEEE floating-point standard (IEEE Standards Association, 1985). This allows the programmer to make many convenient assumptions about how certain numeric conditions will be handled."),e("br"),t._v("\n许多图形程序实际上只是3D数字代码。在此类程序中，数字问题通常至关重要。在过去，以健壮和可移植的方式处理此类问题非常困难，因为机器内部用不同的数字表示，甚至更糟的是，以不同且不兼容的方式处理异常。幸运的是，几乎所有现代计算机都符合IEEE浮点标准（IEEE标准协会，1985）。这允许程序员对如何处理某些数值条件做出许多方便的假设。")]),t._v(" "),e("p",[t._v("  Although IEEE floating-point has many features that are valuable when coding numeric algorithms, there are only a few that are crucial to know for most situations encountered in graphics. First, and most important, is to understand that there are three “special” values for real numbers in IEEE floating-point:"),e("br"),t._v("\n  尽管IEEE浮点具有许多在对数字算法进行编码时非常有价值的功能，但对于图形中遇到的大多数情况，只有少数几个至关重要的知识。首先，也是最重要的一点，是要了解IEEE浮点中的实数有三个“特殊”值：")]),t._v(" "),e("ol",[e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Infinity (∞).")]),t._v(" This is a valid number that is larger than all other valid numbers.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("无穷大(∞)")]),t._v("这是一个有效数字，大于所有其他有效数字。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Minus infinity (−∞).")]),t._v(" This is a valid number that is smaller than all other valid numbers.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("负无穷大(−∞)")]),t._v("这是一个有效数字，小于所有其他有效数字。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("Not a number (NaN).")]),t._v(" This is an invalid number that arises from an operation with undefined consequences, such as zero divided by zero.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("不是数字(NaN)")]),t._v("这是无效操作产生的无效数字，其后果不明确，例如零除以零。")],1)])]),t._v(" "),e("p",[t._v("The designers of IEEE floating-point made some decisions that are extremely convenient for programmers. Many of these relate to the three special values above in handling exceptions such as division by zero. In these cases an exception is logged, but in many cases the programmer can ignore that. Specifically, for any positive real number a, the following rules involving division by infinite values hold:"),e("br"),t._v("\nIEEE浮点的设计人员做出了一些决定，这些决定对于程序员来说非常方便。在处理异常（例如被零除）时，其中许多与上述三个特殊值有关。在这些情况下，会记录异常，但在许多情况下，程序员可以忽略该异常。具体来说，对于任何正实数a，以下规则涉及无穷大除法："),e("br"),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"("}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:")"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-mn",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"0"}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"("}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:")"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-mn",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"0"}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"("}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:")"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-mn",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"0"}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"("}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:")"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-mn",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"0"}}),e("mjx-c",{attrs:{c:"."}})],1)],1)],1)],1)],1),t._v(" "),e("p",[t._v("  Other operations involving infinite values behave the way one would expect. Again for positive a, the behavior is as follows:"),e("br"),t._v("\n  其他涉及无限值的运算的行为与人们期望的一样。 再次对于正数a，其行为如下："),e("br"),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"3"}},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-TeXAtom",{attrs:{space:"3"}},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"3"}},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-TeXAtom",{attrs:{space:"3"}},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mi",{staticClass:"mjx-i",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"N"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"N"}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"3"}},[e("mjx-c",{attrs:{c:"D7"}})],1),e("mjx-TeXAtom",{attrs:{space:"3"}},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-TeXAtom",{attrs:{space:"4"}},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mi",{staticClass:"mjx-i",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"N"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"N"}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-TeXAtom",{attrs:{space:"4"}},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mn",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"0"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-TeXAtom",{attrs:{space:"4"}},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-mn",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"0"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mn",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"0"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mi",{staticClass:"mjx-i",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"N"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"N"}})],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"."}})],1)],1)],1)],1)],1),t._v(" "),e("p",[t._v("The rules in a Boolean expression involving infinite values are as expected:"),e("br"),t._v("\n布尔表达式中涉及无限值的规则符合预期：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("All finite valid numbers are less than +∞")])]),t._v(" "),e("li",[e("p",[t._v("所有有限有效数均小于+∞")])]),t._v(" "),e("li",[e("p",[t._v("All finite valid numbers are greater than −∞.")])]),t._v(" "),e("li",[e("p",[t._v("所有有限有效数均大于-∞。")])]),t._v(" "),e("li",[e("p",[t._v("−∞ is less than +∞.")])]),t._v(" "),e("li",[e("p",[t._v("-∞小于+∞。")])])]),t._v(" "),e("p",[t._v("The rules involving expressions that have NaN values are simple:"),e("br"),t._v("\n涉及具有NaN值的表达式的规则很简单：")]),t._v(" "),e("ol",[e("li",[t._v("Any arithmetic expression that includes NaN results in NaN.")]),t._v(" "),e("li",[t._v("任何包含NaN的算术表达式都将得出NaN。")]),t._v(" "),e("li",[t._v("Any Boolean expression involving NaN is false.")]),t._v(" "),e("li",[t._v("任何涉及NaN的布尔表达式均为false。")])]),t._v(" "),e("p",[t._v("Perhaps the most useful aspect of IEEE floating-point is how divide-by-zero is handled; for any positive real number a, the following rules involving division by zero values hold:"),e("br"),t._v("\nIEEE浮点数最有用的方面可能是如何处理零除； 对于任何正实数a，以下规则涉及零除："),e("br"),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"3"}},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-mn",{staticClass:"mjx-n",attrs:{space:"3"}},[e("mjx-c",{attrs:{c:"0"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:","}})],1)],1)],1)],1),t._v(" "),e("center",[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"/"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"3"}},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-mn",{staticClass:"mjx-n",attrs:{space:"3"}},[e("mjx-c",{attrs:{c:"0"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"2212"}})],1),e("mjx-TeXAtom",[e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"221E"}})],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"."}})],1)],1)],1)],1)],1),t._v(" "),e("p",[t._v("  There are many numeric computations that become much simpler if the programmer takes advantage of the IEEE rules. For example, consider the expression:"),e("br"),t._v("\n  如果程序员利用IEEE规则，许多数字计算将变得更加简单。例如，考虑以下表达式："),e("br"),t._v(" "),e("center",[e("font",{attrs:{size:"5"}},[e("mjx-container",{staticClass:"MathJax",attrs:{jax:"CHTML"}},[e("mjx-math",{staticClass:" MJX-TEX"},[e("mjx-mi",{staticClass:"mjx-i"},[e("mjx-c",{attrs:{c:"a"}})],1),e("mjx-mo",{staticClass:"mjx-n",attrs:{space:"4"}},[e("mjx-c",{attrs:{c:"="}})],1),e("mjx-TeXAtom",{attrs:{space:"4"}},[e("mjx-mfrac",[e("mjx-frac",[e("mjx-num",[e("mjx-nstrut"),e("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[e("mjx-c",{attrs:{c:"1"}})],1)],1),e("mjx-dbox",[e("mjx-dtable",[e("mjx-line"),e("mjx-row",[e("mjx-den",[e("mjx-dstrut"),e("mjx-mrow",{attrs:{size:"s"}},[e("mjx-mfrac",[e("mjx-frac",[e("mjx-num",[e("mjx-nstrut"),e("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[e("mjx-c",{attrs:{c:"1"}})],1)],1),e("mjx-dbox",[e("mjx-dtable",[e("mjx-line"),e("mjx-row",[e("mjx-den",[e("mjx-dstrut"),e("mjx-mi",{staticClass:"mjx-i",attrs:{size:"s"}},[e("mjx-c",{attrs:{c:"b"}})],1)],1)],1)],1)],1)],1)],1),e("mjx-mo",{staticClass:"mjx-n"},[e("mjx-c",{attrs:{c:"+"}})],1),e("mjx-TeXAtom",[e("mjx-mfrac",[e("mjx-frac",[e("mjx-num",[e("mjx-nstrut"),e("mjx-mn",{staticClass:"mjx-n",attrs:{size:"s"}},[e("mjx-c",{attrs:{c:"1"}})],1)],1),e("mjx-dbox",[e("mjx-dtable",[e("mjx-line"),e("mjx-row",[e("mjx-den",[e("mjx-dstrut"),e("mjx-mi",{staticClass:"mjx-i",attrs:{size:"s"}},[e("mjx-c",{attrs:{c:"c"}})],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1)],1),t._v(" "),e("p",[t._v("Such expressions arise with resistors and lenses. If divide-by-zero resulted in a program crash (as was true in many systems before IEEE floating-point), then two if statements would be required to check for small or zero values of b or c. Instead, with IEEE floating-point, if b or c is zero, we will get a zero value for a as desired. Another common technique to avoid special checks is to take advantage of the Boolean properties of NaN. Consider the following code segment:"),e("br"),t._v("\n这样的表达出现在电阻器和透镜中。 如果被零除导致程序崩溃（在IEEE浮点数之前的许多系统中都是如此），则将需要两个if语句来检查b或c的较小值或零值。 相反，对于IEEE浮点数，如果b或c为零，则将根据需要为a获得零值。 避免特殊检查的另一种常用技术是利用NaN的布尔属性。 考虑以下代码段："),e("br"),t._v(" "),e("center",[e("code",[t._v("a = f(x)")]),e("br"),t._v(" "),e("code",[t._v("if (a > 0) then")]),e("br"),t._v(" "),e("code",[t._v("do something")])])],1),t._v(" "),e("p",[t._v("Here, the function f may return “ugly” values such as ∞ or NaN, but the if condition is still well-defined: it is false for a = NaN or a = −∞ and true for a = +∞. With care in deciding which values are returned, often the if can make the right choice, with no special checks needed. This makes programs smaller, more robust, and more efficient."),e("br"),t._v("\n在这里，函数f可能会返回“丑陋”的值，例如∞或NaN，但是if条件仍然是明确定义的：a = NaN或a =-∞时为false，而a = +∞时为true。 在确定返回哪些值时，通常if可以做出正确的选择，而无需进行特殊检查。 这使程序更小，更健壮和更高效。")]),t._v(" "),e("h2",{attrs:{id:"_1-6-效率-efficiency"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-效率-efficiency"}},[t._v("#")]),t._v(" 1.6 效率(Efficiency)")]),t._v(" "),e("p",[t._v("There are no magic rules for making code more efficient. Efficiency is achieved through careful tradeoffs, and these tradeoffs are different for different architectures. However, for the foreseeable future, a good heuristic is that programmers should pay more attention to memory access patterns than to operation counts. This is the opposite of the best heuristic of two decades ago. This switch has occurred because the speed of memory has not kept pace with the speed of processors. Since that trend continues, the importance of limited and coherent memory access for optimization should only increase."),e("br"),t._v("\n没有使代码更高效的魔术规则。通过仔细权衡可以实现效率，并且这些权衡对于不同的体系结构是不同的。但是，在可预见的将来，一个很好的启发法是程序员应该更多地注意内存访问模式，而不是操作次数。这与二十年前的最佳启发式方法相反。之所以发生此切换，是因为内存的速度无法跟上处理器的速度。由于这种趋势继续存在，因此有限和一致的内存访问对于优化的重要性应该只会增加。")]),t._v(" "),e("p",[t._v("  A reasonable approach to making code fast is to proceed in the following order, taking only those steps which are needed:"),e("br"),t._v("\n  一种使代码快速运行的合理方法是按照以下顺序进行，仅采取所需的步骤：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("Write the code in the most straightforward way possible. Compute intermediate results as needed on the fly rather than storing them.")])]),t._v(" "),e("li",[e("p",[t._v("以最直接的方式编写代码。根据需要即时计算中间结果，而不是存储它们。")])]),t._v(" "),e("li",[e("p",[t._v("Compile in optimized mode.")])]),t._v(" "),e("li",[e("p",[t._v("以优化模式进行编译。")])]),t._v(" "),e("li",[e("p",[t._v("Use whatever profiling tools exist to find critical bottlenecks.")])]),t._v(" "),e("li",[e("p",[t._v("使用现有的任何分析工具来查找关键瓶颈。")])]),t._v(" "),e("li",[e("p",[t._v("Examine data structures to look for ways to improve locality. If possible, make data unit sizes match the cache/page size on the target architecture.")])]),t._v(" "),e("li",[e("p",[t._v("检查数据结构以寻找改善位置的方法。如果可能，请使数据单元大小与目标体系结构上的缓存/页面大小匹配。")])]),t._v(" "),e("li",[e("p",[t._v("If profiling reveals bottlenecks in numeric computations, examine the assembly code generated by the compiler for missed efficiencies. Rewrite source code to solve any problems you find.")])]),t._v(" "),e("li",[e("p",[t._v("如果分析揭示了数值计算中的瓶颈，请检查编译器生成的汇编代码是否存在效率低下的情况。重写源代码以解决您发现的任何问题。")])])]),t._v(" "),e("p",[t._v("The most important of these steps is the first one. Most “optimizations” make the code harder to read without speeding things up. In addition, time spent upfront optimizing code is usually better spent correcting bugs or adding features. Also, beware of suggestions from old texts; some classic tricks such as using integers instead of reals may no longer yield speed because modern CPUs can usually perform floating-point operations just as fast as they perform integer operations. In all situations, profiling is needed to be sure of the merit of any optimization for a specific machine and compiler."),e("br"),t._v("\n这些步骤中最重要的是第一个步骤。 大多数“优化”使得在不加快速度的情况下难以阅读代码。 此外，通常花费在前期优化代码上的时间通常会花费在纠正错误或添加功能上。 另外，提防旧文本的建议； 一些经典技巧，例如使用整数而不是实数，可能不再产生速度，因为现代CPU通常可以执行浮点运算，就像执行整数运算一样快。 在所有情况下，都需要进行分析以确保针对特定机器和编译器进行任何优化的优点。")]),t._v(" "),e("h2",{attrs:{id:"_1-7-设计和编码图形程序-designing-and-coding-graphics-programs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-设计和编码图形程序-designing-and-coding-graphics-programs"}},[t._v("#")]),t._v(" 1.7 设计和编码图形程序(Designing and Coding Graphics Programs)")]),t._v(" "),e("p",[t._v("Certain common strategies are often useful in graphics programming. In this section we provide some advice that you may find helpful as you implement the methods you learn about in this book."),e("br"),t._v("\n某些通用策略通常在图形编程中很有用。 在本节中，我们提供一些建议，在您实施本书中学习的方法时可能会有所帮助。")]),t._v(" "),e("h3",{attrs:{id:"_1-7-1-类的设计-class-design"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-1-类的设计-class-design"}},[t._v("#")]),t._v(" 1.7.1 类的设计(Class Design)")]),t._v(" "),e("p",[t._v("A key part of any graphics program is to have good classes or routines for geometric entities such as vectors and matrices, as well as graphics entities such as RGB colors and images. These routines should be made as clean and efficient as possible. A universal design question is whether locations and displacements should be separate classes because they have different operations, e.g., a location multiplied by one-half makes no geometric sense while one-half of a displacement does (Goldman, 1985; DeRose, 1989). There is little agreement on this question, which can spur hours of heated debate among graphics practitioners, but for the sake of example let’s assume we will not make the distinction."),e("br"),t._v("\n任何图形程序的关键部分都是为诸如矢量和矩阵之类的几何实体以及诸如RGB颜色和图像之类的图形实体提供良好的类或例程。 这些例程应尽可能干净有效。 一个通用的设计问题是位置和位移是否应归为不同的类别，因为它们具有不同的运算，例如，位置乘以二分之一就没有几何意义，而位移的二分之一就没有几何意义（Goldman，1985; DeRose，1989）。 在这个问题上几乎没有共识，这可能会激起图形从业者数小时的激烈辩论，但是为了举例说明，我们假设我们不会对此加以区分。")]),t._v(" "),e("p",[t._v("This implies that some basic classes to be written include:"),e("br"),t._v("\n这意味着要编写的一些基本类包括：")]),t._v(" "),e("ul",[e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("vector2.")]),t._v(" A 2D vector class that stores an x- and y-component. It should store these components in a length-2 array so that an indexing operator can be well supported. You should also include operations for vector addition, vector subtraction, dot product, cross product, scalar multiplication, and scalar division.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("vector2.")]),t._v("存储x和y分量的2D向量类。它应将这些组件存储在长度为2的数组中，以便可以很好地支持索引运算符。 您还应该包括用于向量加法，向量减法，点积，叉积，标量乘法和\n标量除法。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("vector3.")]),t._v(" A 3D vector class analogous to vector2.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("vector3.")]),t._v("类似于vector2的3D向量类。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("hvector.")]),t._v(" A homogeneous vector with four components (see Chapter 7).")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("hvector.")]),t._v('具有四个分量的同构(homogeneous 感觉应该翻译为"齐次")向量（请参见第7章）。')],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("rgb.")]),t._v("An RGB color that stores three components. You should also include operations for RGB addition, RGB subtraction, RGB multiplication, scalar multiplication, and scalar division.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("rgb.")]),t._v("存储三个分量的RGB颜色。 您还应该包括用于RGB加法，RGB减法，RGB乘法，标量乘法和标量除法的操作。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("transform.")]),t._v("A 4 × 4 matrix for transformations. You should include a matrix multiply and member functions to apply to locations, directions, and\nsurface normal vectors. As shown in Chapter 6, these are all different.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("transform.")]),t._v("用于变换的4×4矩阵。 您应该包括一个矩阵乘法和成员函数，以应用于位置，方向和表面法线向量。 如第6章所示，它们都是不同的。")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("image.")]),t._v(" A 2D array of RGB pixels with an output operation.")],1)]),t._v(" "),e("li",[e("p",[e("font",{attrs:{color:"#478a4a"}},[t._v("image.")]),t._v("带有输出操作的RGB像素的2D数组。")],1)])]),t._v(" "),e("p",[t._v("In addition, you might or might not want to add classes for intervals, orthonormal bases, and coordinate frames.\n此外，您可能希望也可能不想添加间隔，正交基准和坐标系的类。")]),t._v(" "),e("h3",{attrs:{id:"_1-7-2-float-vs-double"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-2-float-vs-double"}},[t._v("#")]),t._v(" 1.7.2 Float vs. Double")]),t._v(" "),e("p",[t._v("Modern architecture suggests that keeping memory use down and maintaining coherent memory access are the keys to efficiency. This suggests using singleprecision data. However, avoiding numerical problems suggests using doubleprecision arithmetic. The tradeoffs depend on the program, but it is nice to have a default in your class definitions."),e("br"),t._v("\n现代体系结构表明，减少内存使用并保持一致的内存访问是提高效率的关键。 这建议使用单精度数据。 但是，要避免数值问题，建议使用双精度算法。 权衡取决于程序，但是最好在类定义中使用默认值。")]),t._v(" "),e("h3",{attrs:{id:"_1-7-3-调试图形程序-debugging-graphics-programs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-3-调试图形程序-debugging-graphics-programs"}},[t._v("#")]),t._v(" 1.7.3 调试图形程序(Debugging Graphics Programs)")]),t._v(" "),e("p",[t._v("If you ask around, you may find that as programmers become more experienced, they use traditional debuggers less and less. One reason for this is that using such debuggers is more awkward for complex programs than for simple programs. Another reason is that the most difficult errors are conceptual ones where the wrong thing is being implemented, and it is easy to waste large amounts of time stepping through variable values without detecting such cases. We have found several debugging strategies to be particularly useful in graphics."),e("br"),t._v("\n如果您四处询问，您可能会发现，随着程序员变得越来越有经验，他们越来越少地使用传统调试器。 原因之一是，与简单程序相比，对于复杂程序而言，使用此类调试器更为尴尬。 另一个原因是，最困难的错误是在概念错误中执行了错误的操作，并且很容易浪费大量时间逐步遍历变量值而没有检测到这种情况。 我们发现几种调试策略在图形中特别有用。")]),t._v(" "),e("p",[e("font",{attrs:{color:"#474F9C"}},[t._v("科学方法(The Scientific Method)")]),e("br"),t._v("\nIn graphics programs there is an alternative to traditional debugging that is often very useful. The downside to it is that it is very similar to what computer programmers are taught not to do early in their careers, so you may feel “naughty” if you do it: we create an image and observe what is wrong with it. Then, we develop a hypothesis about what is causing the problem and test it. For example, in a ray-tracing program we might have many somewhat random looking dark pixels. This is the classic “shadow acne” problem that most people run into when they write a ray tracer. Traditional debugging is not helpful here; instead, we must realize that the shadow rays are hitting the surface being shaded. We might notice that the color of the dark spots is the ambient color, so the direct lighting is what is missing. Direct lighting can be turned off in shadow, so you might hypothesize that these points are incorrectly being tagged as in shadow when they are not. To test this hypothesis, we could turn off the shadowing check and recompile. This would indicate that these are false shadow tests, and we could continue our detective work. The key reason that this method can sometimes be good practice is that we never had to spot a false value or really determine our conceptual error. Instead, we just narrowed in on our conceptual error experimentally. Typically only a few trials are needed to track things down, and this type of debugging is enjoyable."),e("br"),t._v("\n在图形程序中，有一种替代传统调试的方法，通常非常有用。缺点是，它与计算机程序员在职业生涯早期不做的事情非常相似，因此如果这样做，您可能会感到“调皮”：我们创建图像并观察它的问题所在。然后，我们对导致问题的原因进行了假设，并进行了测试。例如，在光线追踪(ray-tracing)程序中，我们可能会有许多看起来有些随机的暗像素。这是大多数人在编写光线追踪器时遇到的经典“阴影痤疮”问题。传统的调试在这里没有帮助；取而代之的是，我们必须意识到阴影射线正在击中要着色的表面。我们可能会注意到黑点的颜色是环境颜色，因此缺少了直接照明。可以在阴影中关闭直接照明，因此您可能假设这些点在没有阴影时被错误地标记为阴影。为了检验这个假设，我们可以关闭阴影检查并重新编译。这将表明这是错误的阴影测试，我们可以继续进行侦探工作。这种方法有时可以作为良好实践的关键原因是，我们不必发现错误的值或真正确定概​​念错误。相反，我们只是通过实验缩小了我们的概念误差。通常只需要进行几次试验就可以跟踪问题，并且这种调试很有趣。")],1),t._v(" "),e("p",[e("font",{attrs:{color:"#474F9C"}},[t._v("图像作为编码调试输出(Images as Coded Debugging Output)")]),e("br"),t._v("\nIn many cases, the easiest channel by which to get debugging information out of a graphics program is the output image itself. If you want to know the value of some variable for part of a computation that runs for every pixel, you can just modify your program temporarily to copy that value directly to the output image and skip the rest of the calculations that would normally be done. For instance, if you suspect a problem with surface normals is causing a problem with shading, you can copy the normal vectors directly to the image (x goes to red, y goes to green, z goes to blue), resulting in a color-coded illustration of the vectors actually being used in your computation. Or, if you suspect a particular value is sometimes out of its valid range, make your program write bright red pixels where that happens. Other common tricks include drawing the back sides of surfaces with an obvious color (when they are not supposed to be visible), coloring the image by the ID numbers of the objects, or coloring pixels by the amount of work they took to compute.\n在许多情况下，从图形程序中获取调试信息的最简单渠道就是输出图像本身。如果您想知道针对每个像素运行的一部分计算的某个变量的值，则可以临时修改程序以将该值直接复制到输出图像，并跳过其余通常会执行的计算。例如，如果您怀疑表面法线问题导致阴影问题，则可以将法线向量直接复制到图像（x变为红色，y变为绿色，z变为蓝色），从而产生颜色-计算中实际使用的向量的编码插图。或者，如果您怀疑某个特定值有时超出其有效范围，请使程序在发生这种情况的地方写入亮红色像素。其他常见的技巧包括用明显的颜色（在不应看到的情况下）绘制表面的背面，通过对象的ID号为图像着色，或通过计算所需的工作量为像素着色。")],1),t._v(" "),e("p",[e("font",{attrs:{color:"#474F9C"}},[t._v("使用调试器(Using a Debugger)")]),e("br"),t._v("\nThere are still cases, particularly when the scientific method seems to have led to a contradiction, when there’s no substitute for observing exactly what is going on. The trouble is that graphics programs often involve many, many executions of the same code (once per pixel, for instance, or once per triangle), making it completely impractical to step through in the debugger from the start. And the most difficult bugs usually only occur for complicated inputs.\n仍然存在某些情况，尤其是当科学方法似乎导致矛盾时，没有其他方法可以准确地观察正在发生的事情。 问题在于，图形程序通常涉及许多相同代码的执行（例如，每个像素一次，或者每个三角形一次），这使得从一开始就进入调试器是完全不切实际的。 最困难的错误通常仅发生在复杂的输入中。")],1),t._v(" "),e("p",[t._v("A useful approach is to “set a trap” for the bug. First, make sure your program is deterministic—run it in a single thread and make sure that all random numbers are computed from fixed seeds. Then, find out which pixel or triangle is exhibiting the bug and add a statement before the code you suspect is incorrect that will be executed only for the suspect case. For instance, if you find that pixel (126, 247) exhibits the bug, then add:\n一种有用的方法是为错误“设置陷阱”。 首先，确保您的程序是确定性的-在单个线程中运行它，并确保所有随机数都是从固定种子中计算出来的。 然后，找出哪个像素或三角形出现了该错误，并在您怀疑不正确的代码之前添加一条语句，该语句仅在可疑情况下才会执行。 例如，如果您发现像素（126，247）出现错误，请添加："),e("br"),t._v(" "),e("center",[e("code",[t._v("if x = 126 and y = 247 then")]),e("br"),t._v(" "),e("code",[t._v("print “blarg!”")])])],1),t._v(" "),e("p",[t._v("If you set a breakpoint on the print statement, you can drop into the debugger just before the pixel you’re interested in is computed. Some debuggers have a “conditional breakpoint” feature that can achieve the same thing without modifying the code."),e("br"),t._v("\n如果您在print语句上设置了断点，则可以在计算您感兴趣的像素之前进入调试器。 一些调试器具有“条件断点”功能，可以在不修改代码的情况下实现相同的目的。")]),t._v(" "),e("p",[t._v("In the cases where the program crashes, a traditional debugger is useful for pinpointing the site of the crash. You should then start backtracking in the program, using asserts and recompiles, to find where the program went wrong. These asserts should be left in the program for potential future bugs you will add. This again means the traditional step-through process is avoided, because that would not be adding the valuable asserts to your program."),e("br"),t._v("\n在程序崩溃的情况下，传统的调试器对于查明崩溃的位置很有用。 然后，您应该使用断言和重新编译在程序中开始回溯，以查找程序出了问题的地方。 这些断言应留在程序中，以备将来可能添加的错误。 这再次意味着避免了传统的逐步过程，因为那样就不会在程序中添加有价值的断言。")]),t._v(" "),e("p",[e("font",{attrs:{color:"#474F9C"}},[t._v("数据可视化以进行调试(Data Visualization for Debugging)")]),e("br"),t._v("\nOften it is hard to understand what your program is doing, because it computes a lot of intermediate results before it finally goes wrong. The situation is similar to a scientific experiment that measures a lot of data, and one solution is the same: make good plots and illustrations for yourself to understand what the data means. For instance, in a ray tracer you might write code to visualize ray trees so you can see what paths contributed to a pixel, or in an image resampling routine you might make plots that show all the points where samples are being taken from the input. Time spent writing code to visualize your program’s internal state is also repaid in a better understanding of its behavior when it comes time to optimize it."),e("br"),t._v("\n通常很难理解您的程序在做什么，因为它会在最终出错之前计算出许多中间结果。 这种情况类似于测量大量数据的科学实验，并且一种解决方案是相同的：为自己做好图和图解，以了解数据的含义。 例如，在光线跟踪器中，您可以编写代码以可视化光线树，以便可以看到对像素有贡献的路径，或者在图像重采样例程中，您可以绘制出显示从输入中取样的所有点的图。 在优化程序时，也可以节省花在编写代码以可视化程序内部状态上的时间，以更好地了解其行为。")],1),t._v(" "),e("h2",{attrs:{id:"note"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#note"}},[t._v("#")]),t._v(" Note")]),t._v(" "),e("p",[t._v("The discussion of software engineering is influenced by the Effective C++ series (Meyers, 1995, 1997), the Extreme Programming movement (Beck & Andres, 2004), and The Practice of Programming (Kernighan & Pike, 1999). The discussion of experimental debugging is based on discussions with Steve Parker."),e("br"),t._v("\n软件工程的讨论受到有效C ++系列（Meyers，1995，1997），极限编程运动（Beck＆Andres，2004）和编程实践（Kernighan＆Pike，1999）的影响。 实验调试的讨论基于与Steve Parker的讨论。")]),t._v(" "),e("p",[t._v("There are a number of annual conferences related to computer graphics, including ACM SIGGRAPH and SIGGRAPH Asia, Graphics Interface, the Game Developers Conference (GDC), Eurographics, Pacific Graphics, High Performance Graphics, the Eurographics Symposium on Rendering, and IEEE VisWeek. These can be readily found by web searches on their names."),e("br"),t._v("\n有许多与计算机图形学相关的年度会议，包括ACM SIGGRAPH和SIGGRAPH Asia，图形接口，游戏开发者大会（GDC），欧洲图形学，太平洋图形学，高性能图形学，欧洲图形学渲染研讨会和IEEE VisWeek。 通过网络搜索它们的名称可以很容易地找到它们。")])])}),[],!1,null,null,null);a.default=i.exports}}]);