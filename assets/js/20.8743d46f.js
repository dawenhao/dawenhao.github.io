(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{508:function(e,t,a){"use strict";a.r(t);var o=a(4),i=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("The term computer graphics describes any use of computers to create and manipulate images. This book introduces the algorithmic and mathematical tools that can be used to create all kinds of images—realistic visual effects, informative technical illustrations, or beautiful computer animations. Graphics can be two- or three-dimensional; images can be completely synthetic or can be produced by manipulating photographs. This book is about the fundamental algorithms and mathematics, especially those used to produce synthetic images of three-dimensional objects and scenes.")]),e._v(" "),a("p",[e._v("Actually doing computer graphics inevitably requires knowing about specific hardware, file formats, and usually a graphics API (see Section 1.3) or two. Computer graphics is a rapidly evolving field, so the specifics of that knowledge are a moving target. Therefore, in this book we do our best to avoid depending on any specific hardware or API. Readers are encouraged to supplement the text with relevant documentation for their software and hardware environment. Fortunately, the culture of computer graphics has enough standard terminology and concepts that the discussion in this book should map nicely to most environments")]),e._v(" "),a("p",[e._v("This chapter defines some basic terminology and provides some historical background, as well as information sources related to computer graphics.")]),e._v(" "),a("h1",{attrs:{id:"_1-7-设计和编码图形程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-设计和编码图形程序"}},[e._v("#")]),e._v(" 1.7 设计和编码图形程序")]),e._v(" "),a("p",[e._v("某些通用策略通常在图形编程中很有用。 在本节中，我们提供一些建议，在您实施本书中学习的方法时可能会有所帮助。")]),e._v(" "),a("h2",{attrs:{id:"_1-7-1-类的设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-1-类的设计"}},[e._v("#")]),e._v(" 1.7.1 类的设计")]),e._v(" "),a("p",[e._v("任何图形程序的关键部分都是为诸如矢量和矩阵之类的几何实体以及诸如RGB颜色和图像之类的图形实体提供良好的类或例程。 这些例程应尽可能干净有效。 一个通用的设计问题是位置和位移是否应归为不同的类别，因为它们具有不同的运算，例如，位置乘以二分之一就没有几何意义，而位移的二分之一就没有几何意义（Goldman，1985; DeRose，1989）。 在这个问题上几乎没有共识，这可能会激起图形从业者数小时的激烈辩论，但是为了举例说明，我们假设我们不会对此加以区分。")]),e._v(" "),a("p",[e._v("这意味着要编写的一些基本类包括：")]),e._v(" "),a("ul",[a("li",[e._v("vector2.存储x和y分量的2D向量类。它应将这些组件存储在长度为2的数组中，以便可以很好地支持索引运算符。 您还应该包括用于向量加法，向量减法，点积，叉积，标量乘法和\n标量除法。")]),e._v(" "),a("li",[e._v("vector3.类似于vector2的3D向量类。")]),e._v(" "),a("li",[e._v('hvector.具有四个分量的同构(homogeneous 感觉应该翻译为"齐次")向量（请参见第7章）。')]),e._v(" "),a("li",[e._v("rgb.存储三个分量的RGB颜色。 您还应该包括用于RGB加法，RGB减法，RGB乘法，标量乘法和标量除法的操作。")]),e._v(" "),a("li",[e._v("transform.用于变换的4×4矩阵。 您应该包括一个矩阵乘法和成员函数，以应用于位置，方向和表面法线向量。 如第6章所示，它们都是不同的。")]),e._v(" "),a("li",[e._v("image.带有输出操作的RGB像素的2D数组。\n此外，您可能希望也可能不想添加间隔，正交基准和坐标系的类。")])]),e._v(" "),a("h2",{attrs:{id:"_1-7-2-float-vs-double"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-2-float-vs-double"}},[e._v("#")]),e._v(" 1.7.2 Float vs. Double")]),e._v(" "),a("p",[e._v("现代体系结构表明，减少内存使用并保持一致的内存访问是提高效率的关键。 这建议使用单精度数据。 但是，要避免数值问题，建议使用双精度算法。 权衡取决于程序，但是最好在类定义中使用默认值。")]),e._v(" "),a("h2",{attrs:{id:"_1-7-3-调试图形程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-3-调试图形程序"}},[e._v("#")]),e._v(" 1.7.3 调试图形程序")]),e._v(" "),a("p",[e._v("如果您四处询问，您可能会发现，随着程序员变得越来越有经验，他们越来越少地使用传统调试器。 原因之一是，与简单程序相比，对于复杂程序而言，使用此类调试器更为尴尬。 另一个原因是，最困难的错误是在概念错误中执行了错误的操作，并且很容易浪费大量时间逐步遍历变量值而没有检测到这种情况。 我们发现几种调试策略在图形中特别有用。")]),e._v(" "),a("p",[a("font",{attrs:{color:"#474F9C"}},[e._v("科学方法(The Scientific Method)")]),a("br"),e._v("\nIn graphics programs there is an alternative to traditional debugging that is often very useful. The downside to it is that it is very similar to what computer programmers are taught not to do early in their careers, so you may feel “naughty” if you do it: we create an image and observe what is wrong with it. Then, we develop a hypothesis about what is causing the problem and test it. For example, in a ray-tracing program we might have many somewhat random looking dark pixels. This is the classic “shadow acne” problem that most people run into when they write a ray tracer. Traditional debugging is not helpful here; instead, we must realize that the shadow rays are hitting the surface being shaded. We might notice that the color of the dark spots is the ambient color, so the direct lighting is what is missing. Direct lighting can be turned off in shadow, so you might hypothesize that these points are incorrectly being tagged as in shadow when they are not. To test this hypothesis, we could turn off the shadowing check and recompile. This would indicate that these are false shadow tests, and we could continue our detective work. The key reason that this method can sometimes be good practice is that we never had to spot a false value or really determine our conceptual error. Instead, we just narrowed in on our conceptual error experimentally. Typically only a few trials are needed to track things down, and this type of debugging is enjoyable."),a("br"),e._v("\n在图形程序中，有一种替代传统调试的方法，通常非常有用。缺点是，它与计算机程序员在职业生涯早期不做的事情非常相似，因此如果这样做，您可能会感到“调皮”：我们创建图像并观察它的问题所在。然后，我们对导致问题的原因进行了假设，并进行了测试。例如，在光线追踪(ray-tracing)程序中，我们可能会有许多看起来有些随机的暗像素。这是大多数人在编写光线追踪器时遇到的经典“阴影痤疮”问题。传统的调试在这里没有帮助；取而代之的是，我们必须意识到阴影射线正在击中要着色的表面。我们可能会注意到黑点的颜色是环境颜色，因此缺少了直接照明。可以在阴影中关闭直接照明，因此您可能假设这些点在没有阴影时被错误地标记为阴影。为了检验这个假设，我们可以关闭阴影检查并重新编译。这将表明这是错误的阴影测试，我们可以继续进行侦探工作。这种方法有时可以作为良好实践的关键原因是，我们不必发现错误的值或真正确定概​​念错误。相反，我们只是通过实验缩小了我们的概念误差。通常只需要进行几次试验就可以跟踪问题，并且这种调试很有趣。")],1),e._v(" "),a("p",[a("font",{attrs:{color:"#474F9C"}},[e._v("图像作为编码调试输出(Images as Coded Debugging Output)")]),a("br"),e._v("\nIn many cases, the easiest channel by which to get debugging information out of a graphics program is the output image itself. If you want to know the value of some variable for part of a computation that runs for every pixel, you can just modify your program temporarily to copy that value directly to the output image and skip the rest of the calculations that would normally be done. For instance, if you suspect a problem with surface normals is causing a problem with shading, you can copy the normal vectors directly to the image (x goes to red, y goes to green, z goes to blue), resulting in a color-coded illustration of the vectors actually being used in your computation. Or, if you suspect a particular value is sometimes out of its valid range, make your program write bright red pixels where that happens. Other common tricks include drawing the back sides of surfaces with an obvious color (when they are not supposed to be visible), coloring the image by the ID numbers of the objects, or coloring pixels by the amount of work they took to compute.\n在许多情况下，从图形程序中获取调试信息的最简单渠道就是输出图像本身。如果您想知道针对每个像素运行的一部分计算的某个变量的值，则可以临时修改程序以将该值直接复制到输出图像，并跳过其余通常会执行的计算。例如，如果您怀疑表面法线问题导致阴影问题，则可以将法线向量直接复制到图像（x变为红色，y变为绿色，z变为蓝色），从而产生颜色-计算中实际使用的向量的编码插图。或者，如果您怀疑某个特定值有时超出其有效范围，请使程序在发生这种情况的地方写入亮红色像素。其他常见的技巧包括用明显的颜色（在不应看到的情况下）绘制表面的背面，通过对象的ID号为图像着色，或通过计算所需的工作量为像素着色。")],1),e._v(" "),a("p",[a("font",{attrs:{color:"#474F9C"}},[e._v("使用调试器(Using a Debugger)")]),a("br"),e._v("\nThere are still cases, particularly when the scientific method seems to have led to a contradiction, when there’s no substitute for observing exactly what is going on. The trouble is that graphics programs often involve many, many executions of the same code (once per pixel, for instance, or once per triangle), making it completely impractical to step through in the debugger from the start. And the most difficult bugs usually only occur for complicated inputs.\n仍然存在某些情况，尤其是当科学方法似乎导致矛盾时，没有其他方法可以准确地观察正在发生的事情。 问题在于，图形程序通常涉及许多相同代码的执行（例如，每个像素一次，或者每个三角形一次），这使得从一开始就进入调试器是完全不切实际的。 最困难的错误通常仅发生在复杂的输入中。")],1),e._v(" "),a("p",[e._v("A useful approach is to “set a trap” for the bug. First, make sure your program is deterministic—run it in a single thread and make sure that all random numbers are computed from fixed seeds. Then, find out which pixel or triangle is exhibiting the bug and add a statement before the code you suspect is incorrect that will be executed only for the suspect case. For instance, if you find that pixel (126, 247) exhibits the bug, then add:\n一种有用的方法是为错误“设置陷阱”。 首先，确保您的程序是确定性的-在单个线程中运行它，并确保所有随机数都是从固定种子中计算出来的。 然后，找出哪个像素或三角形出现了该错误，并在您怀疑不正确的代码之前添加一条语句，该语句仅在可疑情况下才会执行。 例如，如果您发现像素（126，247）出现错误，请添加："),a("br"),e._v(" "),a("code",[e._v("if x = 126 and y = 247 then")]),a("br"),e._v(" "),a("code",[e._v("print “blarg!”")])]),e._v(" "),a("p",[e._v("If you set a breakpoint on the print statement, you can drop into the debugger just before the pixel you’re interested in is computed. Some debuggers have a “conditional breakpoint” feature that can achieve the same thing without modifying the code."),a("br"),e._v("\n如果您在print语句上设置了断点，则可以在计算您感兴趣的像素之前进入调试器。 一些调试器具有“条件断点”功能，可以在不修改代码的情况下实现相同的目的。")]),e._v(" "),a("p",[e._v("In the cases where the program crashes, a traditional debugger is useful for pinpointing the site of the crash. You should then start backtracking in the program, using asserts and recompiles, to find where the program went wrong. These asserts should be left in the program for potential future bugs you will add. This again means the traditional step-through process is avoided, because that would not be adding the valuable asserts to your program."),a("br"),e._v("\n在程序崩溃的情况下，传统的调试器对于查明崩溃的位置很有用。 然后，您应该使用断言和重新编译在程序中开始回溯，以查找程序出了问题的地方。 这些断言应留在程序中，以备将来可能添加的错误。 这再次意味着避免了传统的逐步过程，因为那样就不会在程序中添加有价值的断言。")]),e._v(" "),a("p",[a("font",{attrs:{color:"#474F9C"}},[e._v("数据可视化以进行调试(Data Visualization for Debugging)")]),a("br"),e._v("\nOften it is hard to understand what your program is doing, because it computes a lot of intermediate results before it finally goes wrong. The situation is similar to a scientific experiment that measures a lot of data, and one solution is the same: make good plots and illustrations for yourself to understand what the data means. For instance, in a ray tracer you might write code to visualize ray trees so you can see what paths contributed to a pixel, or in an image resampling routine you might make plots that show all the points where samples are being taken from the input. Time spent writing code to visualize your program’s internal state is also repaid in a better understanding of its behavior when it comes time to optimize it."),a("br"),e._v("\n通常很难理解您的程序在做什么，因为它会在最终出错之前计算出许多中间结果。 这种情况类似于测量大量数据的科学实验，并且一种解决方案是相同的：为自己做好图和图解，以了解数据的含义。 例如，在光线跟踪器中，您可以编写代码以可视化光线树，以便可以看到对像素有贡献的路径，或者在图像重采样例程中，您可以绘制出显示从输入中取样的所有点的图。 在优化程序时，也可以节省花在编写代码以可视化程序内部状态上的时间，以更好地了解其行为。")],1),e._v(" "),a("h1",{attrs:{id:"notes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#notes"}},[e._v("#")]),e._v(" Notes")]),e._v(" "),a("p",[e._v("The discussion of software engineering is influenced by the Effective C++ series (Meyers, 1995, 1997), the Extreme Programming movement (Beck & Andres, 2004), and The Practice of Programming (Kernighan & Pike, 1999). The discussion of experimental debugging is based on discussions with Steve Parker."),a("br"),e._v("\n软件工程的讨论受到有效C ++系列（Meyers，1995，1997），极限编程运动（Beck＆Andres，2004）和编程实践（Kernighan＆Pike，1999）的影响。 实验调试的讨论基于与Steve Parker的讨论。")]),e._v(" "),a("p",[e._v("There are a number of annual conferences related to computer graphics, including ACM SIGGRAPH and SIGGRAPH Asia, Graphics Interface, the Game Developers Conference (GDC), Eurographics, Pacific Graphics, High Performance Graphics, the Eurographics Symposium on Rendering, and IEEE VisWeek. These can be readily found by web searches on their names."),a("br"),e._v("\n有许多与计算机图形学相关的年度会议，包括ACM SIGGRAPH和SIGGRAPH Asia，图形接口，游戏开发者大会（GDC），欧洲图形学，太平洋图形学，高性能图形学，欧洲图形学渲染研讨会和IEEE VisWeek。 通过网络搜索它们的名称可以很容易地找到它们。")])])}),[],!1,null,null,null);t.default=i.exports}}]);